# è´­æˆ¿å†³ç­–æ™ºèƒ½åŠ©æ‰‹ - æŠ€æœ¯å®ç°æ–¹æ¡ˆ

## æ¦‚è¿°

æœ¬æ–‡æ¡£å®šä¹‰äº†è´­æˆ¿å†³ç­–æ™ºèƒ½åŠ©æ‰‹çš„å…·ä½“æŠ€æœ¯å®ç°æ–¹æ¡ˆã€‚

**å¯¹å¤–è¡¨è¿°**: å¤šæ™ºèƒ½ä½“åä½œç³»ç»Ÿ  
**å†…éƒ¨å®ç°**: ä¼ªå¤šAgentï¼ˆå•Agent + å¤šè§’è‰² + å¤šå·¥å…·ï¼‰ï¼Œæ‰‹æ“å®ç°  
**ä¸ä½¿ç”¨LangChainçš„ç†ç”±**: éœ€æ±‚ä¸å¤æ‚ï¼Œæ‰‹æ“æ›´å¯æ§ã€æ›´æ˜“è°ƒè¯•ã€ä»£ç æ›´æ¸…æ™°

---

## ä¸€ã€æŠ€æœ¯æ ˆ

### åç«¯

| æ¨¡å— | æŠ€æœ¯ | ç‰ˆæœ¬ | è¯´æ˜ |
|------|------|------|------|
| Webæ¡†æ¶ | FastAPI | 0.109+ | å¼‚æ­¥æ”¯æŒï¼Œè‡ªåŠ¨æ–‡æ¡£ |
| ASGIæœåŠ¡å™¨ | Uvicorn | 0.27+ | é«˜æ€§èƒ½ |
| HTTPå®¢æˆ·ç«¯ | httpx | 0.26+ | å¼‚æ­¥è°ƒç”¨LLM API |
| å‘é‡åº“ | Chroma | 0.4+ | RAGæ£€ç´¢ |
| Embedding | sentence-transformers | - | æœ¬åœ°Embeddingæ¨¡å‹ |
| æ•°æ®åº“ | PostgreSQL | 15+ | ç¨³å®šå¯é ï¼ŒJSONæ”¯æŒå¥½ |
| ç¼“å­˜ | Redis | 7+ | ä¼šè¯ç®¡ç†ã€çƒ­ç‚¹ç¼“å­˜ |

### å‰ç«¯

| æ¨¡å— | æŠ€æœ¯ | è¯´æ˜ |
|------|------|------|
| æ¡†æ¶ | Vue.js 3 | ç»„åˆå¼API |
| æ„å»º | Vite | å¿«é€Ÿå¼€å‘ |
| UIç»„ä»¶ | Element Plus | æˆç†Ÿç¨³å®š |
| HTTP | Axios | è¯·æ±‚å°è£… |
| å›¾è¡¨ | ECharts | èµ°åŠ¿å›¾å±•ç¤º |

### LLM

| æ¨¡å‹ | ç”¨é€” | ä»·æ ¼ |
|------|------|------|
| DeepSeek-V3 | ä¸»åŠ›æ¨¡å‹ | ï¿¥1/ç™¾ä¸‡token |
| DeepSeek-R1 | å¤æ‚æ¨ç†ï¼ˆå¯é€‰ï¼‰ | ï¿¥4/ç™¾ä¸‡token |

---

## äºŒã€é¡¹ç›®ç»“æ„

```
house-purchase-assistant/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ main.py              # FastAPIå…¥å£
â”‚   â”‚   â”œâ”€â”€ config.py            # é…ç½®ç®¡ç†
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ auth.py          # ç”¨æˆ·è®¤è¯æ¥å£
â”‚   â”‚   â”‚   â”œâ”€â”€ chat.py          # å¯¹è¯æ¥å£
â”‚   â”‚   â”‚   â”œâ”€â”€ calculator.py    # è®¡ç®—å™¨æ¥å£
â”‚   â”‚   â”‚   â””â”€â”€ conversation.py  # å¯¹è¯å†å²æ¥å£
â”‚   â”‚   â”œâ”€â”€ agent/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ engine.py        # Agentå¼•æ“æ ¸å¿ƒ
â”‚   â”‚   â”‚   â”œâ”€â”€ roles.py         # è§’è‰²å®šä¹‰
â”‚   â”‚   â”‚   â”œâ”€â”€ intent.py        # æ„å›¾è¯†åˆ«
â”‚   â”‚   â”‚   â””â”€â”€ tools/
â”‚   â”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚       â”œâ”€â”€ base.py      # å·¥å…·åŸºç±»
â”‚   â”‚   â”‚       â”œâ”€â”€ financial.py # è´¢åŠ¡è®¡ç®—å·¥å…·
â”‚   â”‚   â”‚       â”œâ”€â”€ market.py    # å¸‚åœºæŸ¥è¯¢å·¥å…·
â”‚   â”‚   â”‚       â”œâ”€â”€ policy.py    # æ”¿ç­–æ£€ç´¢å·¥å…·
â”‚   â”‚   â”‚       â””â”€â”€ news.py      # æ–°é—»æœç´¢å·¥å…·
â”‚   â”‚   â”œâ”€â”€ llm/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ client.py        # LLMå®¢æˆ·ç«¯å°è£…
â”‚   â”‚   â”œâ”€â”€ rag/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ embeddings.py    # EmbeddingæœåŠ¡
â”‚   â”‚   â”‚   â””â”€â”€ retriever.py     # æ£€ç´¢æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ models/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ schemas.py       # Pydanticæ¨¡å‹
â”‚   â”‚   â”œâ”€â”€ services/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â””â”€â”€ conversation.py  # å¯¹è¯å†å²æœåŠ¡
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â””â”€â”€ __init__.py
â”‚   â”œâ”€â”€ data/                    # æ•°æ®æ–‡ä»¶ï¼ˆä»æ ¹ç›®å½•é“¾æ¥ï¼‰
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ Dockerfile
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ main.js
â”‚   â”‚   â”œâ”€â”€ App.vue
â”‚   â”‚   â”œâ”€â”€ views/
â”‚   â”‚   â”‚   â”œâ”€â”€ Chat.vue         # å¯¹è¯é¡µé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ Calculator.vue   # è®¡ç®—å™¨é¡µé¢
â”‚   â”‚   â”‚   â””â”€â”€ Market.vue       # å¸‚åœºåˆ†æé¡µé¢
â”‚   â”‚   â”œâ”€â”€ components/
â”‚   â”‚   â”‚   â”œâ”€â”€ ChatMessage.vue
â”‚   â”‚   â”‚   â”œâ”€â”€ RoleTag.vue
â”‚   â”‚   â”‚   â””â”€â”€ PriceChart.vue
â”‚   â”‚   â”œâ”€â”€ api/
â”‚   â”‚   â”‚   â””â”€â”€ index.js
â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ vite.config.js
â”œâ”€â”€ data/                        # æ•°æ®æ–‡ä»¶
â”‚   â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ market/
â”‚   â””â”€â”€ knowledge/
â”œâ”€â”€ docs/                        # æ–‡æ¡£
â””â”€â”€ docker-compose.yml
```


---

## ä¸‰ã€æ ¸å¿ƒæ¨¡å—å®ç°

### 3.1 LLMå®¢æˆ·ç«¯å°è£…

```python
# app/llm/client.py
import httpx
from typing import Optional

class DeepSeekClient:
    """DeepSeek API å®¢æˆ·ç«¯"""
    
    def __init__(self, api_key: str, base_url: str = "https://api.deepseek.com"):
        self.api_key = api_key
        self.base_url = base_url
        self.client = httpx.AsyncClient(timeout=60.0)
    
    async def chat(
        self,
        messages: list[dict],
        model: str = "deepseek-chat",
        temperature: float = 0.7,
        tools: Optional[list[dict]] = None
    ) -> dict:
        """è°ƒç”¨å¯¹è¯æ¥å£"""
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "model": model,
            "messages": messages,
            "temperature": temperature
        }
        
        if tools:
            payload["tools"] = tools
            payload["tool_choice"] = "auto"
        
        response = await self.client.post(
            f"{self.base_url}/v1/chat/completions",
            headers=headers,
            json=payload
        )
        response.raise_for_status()
        return response.json()
    
    async def chat_stream(self, messages: list[dict], **kwargs):
        """æµå¼è¾“å‡º"""
        kwargs["stream"] = True
        # å®ç°æµå¼å“åº”...
```

### 3.2 å·¥å…·å®šä¹‰æ¡†æ¶

```python
# app/agent/tools/base.py
from abc import ABC, abstractmethod
from typing import Any
from pydantic import BaseModel, Field

class ToolParameter(BaseModel):
    """å·¥å…·å‚æ•°å®šä¹‰"""
    name: str = Field(..., description="å‚æ•°åç§°")
    type: str = Field(..., description="å‚æ•°ç±»å‹: string, number, integer, boolean")
    description: str = Field(..., description="å‚æ•°æè¿°")
    required: bool = Field(default=True, description="æ˜¯å¦å¿…éœ€")
    enum: list[str] | None = Field(default=None, description="æšä¸¾å€¼åˆ—è¡¨")

    def to_json_schema(self) -> dict:
        """è½¬æ¢ä¸º JSON Schema æ ¼å¼"""
        schema = {
            "type": self.type,
            "description": self.description
        }
        if self.enum:
            schema["enum"] = self.enum
        return schema

class BaseTool(ABC):
    """å·¥å…·åŸºç±»ï¼Œæ‰€æœ‰å·¥å…·å¿…é¡»ç»§æ‰¿æ­¤ç±»"""
    name: str  # å·¥å…·åç§°
    description: str  # å·¥å…·æè¿°
    parameters: list[ToolParameter]  # å‚æ•°åˆ—è¡¨
    
    @abstractmethod
    async def execute(self, **kwargs) -> dict:
        """æ‰§è¡Œå·¥å…·"""
        pass
    
    def validate_params(self, **kwargs) -> None:
        """
        éªŒè¯è¾“å…¥å‚æ•°
        
        Raises:
            ValueError: å‚æ•°éªŒè¯å¤±è´¥æ—¶æŠ›å‡º
        """
        for param in self.parameters:
            if param.required and param.name not in kwargs:
                raise ValueError(f"ç¼ºå°‘å¿…éœ€å‚æ•°: {param.name}")
            if param.name in kwargs:
                value = kwargs[param.name]
                # æ£€æŸ¥æšä¸¾å€¼
                if param.enum and value not in param.enum:
                    raise ValueError(f"å‚æ•° {param.name} å€¼æ— æ•ˆ: {value}")
    
    def to_openai_schema(self) -> dict:
        """è½¬æ¢ä¸ºOpenAIå·¥å…·æ ¼å¼"""
        properties = {}
        required = []
        for param in self.parameters:
            properties[param.name] = param.to_json_schema()
            if param.required:
                required.append(param.name)
        return {
            "type": "function",
            "function": {
                "name": self.name,
                "description": self.description,
                "parameters": {
                    "type": "object",
                    "properties": properties,
                    "required": required
                }
            }
        }
```

### 3.3 è´¢åŠ¡è®¡ç®—å·¥å…·ç¤ºä¾‹

```python
# app/agent/tools/financial.py
from .base import BaseTool, ToolParameter

class CalcLoanTool(BaseTool):
    """è´·æ¬¾è®¡ç®—å·¥å…·"""
    name = "calc_loan"
    description = "è®¡ç®—è´·æ¬¾æ–¹æ¡ˆï¼ŒåŒ…æ‹¬æœˆä¾›ã€æ€»åˆ©æ¯ç­‰"
    parameters = [
        ToolParameter(name="price", type="number", description="æˆ¿å±‹æ€»ä»·ï¼ˆå…ƒï¼‰"),
        ToolParameter(name="down_payment_ratio", type="number", description="é¦–ä»˜æ¯”ä¾‹ï¼Œå¦‚0.3è¡¨ç¤º30%"),
        ToolParameter(name="years", type="integer", description="è´·æ¬¾å¹´é™"),
        ToolParameter(name="rate", type="number", description="å¹´åˆ©ç‡ï¼Œå¦‚3.6è¡¨ç¤º3.6%"),
        ToolParameter(name="method", type="string", description="è¿˜æ¬¾æ–¹å¼ï¼šequal_payment(ç­‰é¢æœ¬æ¯) æˆ– equal_principal(ç­‰é¢æœ¬é‡‘)", required=False)
    ]
    
    async def execute(
        self,
        price: float,
        down_payment_ratio: float,
        years: int,
        rate: float,
        method: str = "equal_payment"
    ) -> dict:
        down_payment = price * down_payment_ratio
        loan_amount = price - down_payment
        monthly_rate = rate / 100 / 12
        months = years * 12
        
        if method == "equal_payment":
            # ç­‰é¢æœ¬æ¯
            if monthly_rate > 0:
                monthly_payment = loan_amount * monthly_rate * (1 + monthly_rate)**months / ((1 + monthly_rate)**months - 1)
            else:
                monthly_payment = loan_amount / months
            total_payment = monthly_payment * months
            total_interest = total_payment - loan_amount
        else:
            # ç­‰é¢æœ¬é‡‘
            principal_per_month = loan_amount / months
            first_month_interest = loan_amount * monthly_rate
            first_month_payment = principal_per_month + first_month_interest
            total_interest = (loan_amount * monthly_rate * (months + 1)) / 2
            monthly_payment = first_month_payment  # é¦–æœˆ
            total_payment = loan_amount + total_interest
        
        return {
            "down_payment": round(down_payment, 2),
            "loan_amount": round(loan_amount, 2),
            "monthly_payment": round(monthly_payment, 2),
            "total_payment": round(total_payment, 2),
            "total_interest": round(total_interest, 2),
            "years": years,
            "rate": rate,
            "method": "ç­‰é¢æœ¬æ¯" if method == "equal_payment" else "ç­‰é¢æœ¬é‡‘"
        }
```


### 3.4 è§’è‰²å®šä¹‰

```python
# app/agent/roles.py
from dataclasses import dataclass

@dataclass
class Role:
    """è§’è‰²å®šä¹‰"""
    id: str
    name: str
    icon: str
    description: str
    system_prompt: str
    tools: list[str]
    trigger_keywords: list[str]

ROLES = {
    "financial_advisor": Role(
        id="financial_advisor",
        name="è´¢åŠ¡é¡¾é—®",
        icon="ğŸ’°",
        description="ä¸“ä¸šçš„è´­æˆ¿è´¢åŠ¡é¡¾é—®",
        system_prompt="""ä½ æ˜¯ä¸“ä¸šçš„è´­æˆ¿è´¢åŠ¡é¡¾é—®ï¼Œå…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š
- ç²¾é€šå…¬ç§¯é‡‘è´·æ¬¾ã€å•†ä¸šè´·æ¬¾ã€ç»„åˆè´·æ¬¾çš„è®¡ç®—
- ç†Ÿæ‚‰å„ç±»è´­æˆ¿ç¨è´¹ï¼ˆå¥‘ç¨ã€å¢å€¼ç¨ã€ä¸ªç¨ã€ä¸­ä»‹è´¹ç­‰ï¼‰
- èƒ½å¤Ÿè¯„ä¼°ç”¨æˆ·çš„è¿˜æ¬¾å‹åŠ›å’Œè´­æˆ¿èƒ½åŠ›
- ç»™å‡ºä¸“ä¸šã€å‡†ç¡®ã€æ˜“æ‡‚çš„è´¢åŠ¡å»ºè®®

å›ç­”è¦æ±‚ï¼š
1. æ•°æ®å‡†ç¡®ï¼Œç»™å‡ºå…·ä½“æ•°å­—
2. è§£é‡Šè®¡ç®—è¿‡ç¨‹
3. è¯„ä¼°é£é™©å’Œå‹åŠ›
4. ç»™å‡ºå¯è¡Œå»ºè®®""",
        tools=["calc_loan", "calc_tax", "calc_total_cost", "assess_pressure"],
        trigger_keywords=["è´·æ¬¾", "æœˆä¾›", "é¦–ä»˜", "ç¨è´¹", "èƒ½ä¹°å—", "ä¹°å¾—èµ·", "å‹åŠ›", "æˆæœ¬", "åˆ©æ¯"]
    ),
    
    "policy_expert": Role(
        id="policy_expert",
        name="æ”¿ç­–ä¸“å®¶",
        icon="ğŸ“‹",
        description="è´­æˆ¿æ”¿ç­–ä¸“å®¶",
        system_prompt="""ä½ æ˜¯è´­æˆ¿æ”¿ç­–ä¸“å®¶ï¼Œå…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š
- ç†Ÿæ‚‰å—å®ã€æŸ³å·çš„é™è´­é™è´·æ”¿ç­–
- äº†è§£å…¬ç§¯é‡‘è´·æ¬¾æ”¿ç­–å’Œç”³è¯·æ¡ä»¶
- æŒæ¡è´­æˆ¿æµç¨‹å’Œæ‰€éœ€ææ–™
- èƒ½è§£ç­”å„ç±»è´­æˆ¿æ”¿ç­–é—®é¢˜

å›ç­”è¦æ±‚ï¼š
1. å‡†ç¡®å¼•ç”¨æ”¿ç­–å†…å®¹
2. è¯´æ˜æ”¿ç­–æ¥æºå’Œæ—¶æ•ˆ
3. è§£é‡Šé€‚ç”¨æ¡ä»¶
4. æé†’æ³¨æ„äº‹é¡¹""",
        tools=["search_policy", "search_faq", "search_guide"],
        trigger_keywords=["é™è´­", "æ”¿ç­–", "èµ„æ ¼", "æ¡ä»¶", "å…¬ç§¯é‡‘", "æµç¨‹", "ææ–™", "æ‰‹ç»­", "è§„å®š"]
    ),
    
    "market_analyst": Role(
        id="market_analyst",
        name="å¸‚åœºåˆ†æå¸ˆ",
        icon="ğŸ“ˆ",
        description="æˆ¿åœ°äº§å¸‚åœºåˆ†æå¸ˆ",
        system_prompt="""ä½ æ˜¯æˆ¿åœ°äº§å¸‚åœºåˆ†æå¸ˆï¼Œå…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š
- åˆ†ææˆ¿ä»·èµ°åŠ¿å’Œå¸‚åœºè¶‹åŠ¿
- å¯¹æ¯”ä¸åŒåŒºåŸŸçš„æˆ¿ä»·å’Œå‘å±•æ½œåŠ›
- åˆ†æä¾›éœ€å…³ç³»å’Œå»åŒ–å‘¨æœŸ
- åˆ¤æ–­è´­æˆ¿æ—¶æœºå¹¶ç»™å‡ºå»ºè®®

å›ç­”è¦æ±‚ï¼š
1. æ•°æ®é©±åŠ¨ï¼Œå¼•ç”¨å…·ä½“æ•°æ®
2. å®¢è§‚åˆ†æï¼Œä¸å¤¸å¤§ä¸è´¬ä½
3. ç»™å‡ºè¶‹åŠ¿åˆ¤æ–­
4. è¯´æ˜åˆ¤æ–­ä¾æ®""",
        tools=["query_market", "query_price_trend", "compare_districts", "judge_timing", "search_news"],
        trigger_keywords=["æˆ¿ä»·", "èµ°åŠ¿", "æ¶¨", "è·Œ", "æ—¶æœº", "åŒºåŸŸ", "å¯¹æ¯”", "å¸‚åœº", "è¡Œæƒ…", "è¶‹åŠ¿"]
    ),
    
    "purchase_consultant": Role(
        id="purchase_consultant",
        name="è´­æˆ¿é¡¾é—®",
        icon="âœ…",
        description="ç»¼åˆè´­æˆ¿é¡¾é—®",
        system_prompt="""ä½ æ˜¯ç»¼åˆè´­æˆ¿é¡¾é—®ï¼Œå…·å¤‡ä»¥ä¸‹èƒ½åŠ›ï¼š
- æ•´åˆè´¢åŠ¡ã€æ”¿ç­–ã€å¸‚åœºç­‰å¤šæ–¹é¢ä¿¡æ¯
- ç»™å‡ºç»¼åˆæ€§çš„è´­æˆ¿å»ºè®®
- æç¤ºæ½œåœ¨é£é™©
- è§„åˆ’ä¸‹ä¸€æ­¥è¡ŒåŠ¨

å›ç­”è¦æ±‚ï¼š
1. ç»¼åˆå„æ–¹é¢ä¿¡æ¯
2. å»ºè®®å…·ä½“å¯è¡Œ
3. é£é™©æç¤ºåˆ°ä½
4. ç»™å‡ºè¡ŒåŠ¨æ¸…å•""",
        tools=["generate_report"],
        trigger_keywords=["å»ºè®®", "æ€ä¹ˆåŠ", "ä¸‹ä¸€æ­¥", "ç»¼åˆ", "æŠ¥å‘Š", "æ€»ç»“"]
    )
}
```

### 3.5 æ„å›¾è¯†åˆ«

```python
# app/agent/intent.py
"""
æ„å›¾è¯†åˆ«æ¨¡å— - DAG æ‰§è¡Œè®¡åˆ’ç”Ÿæˆ

æ ¸å¿ƒæ”¹è¿›ï¼š
1. å»æ‰å…³é”®è¯åŒ¹é…ï¼Œå®Œå…¨ç”± LLM è¯†åˆ«æ„å›¾
2. LLM è¿”å› DAG æ ¼å¼çš„æ‰§è¡Œè®¡åˆ’ï¼ŒåŒ…å«è§’è‰²å’Œä¾èµ–å…³ç³»
3. æ”¯æŒå¾ªç¯ä¾èµ–æ£€æµ‹
"""
from dataclasses import dataclass, field

@dataclass
class ExecutionNode:
    """
    æ‰§è¡ŒèŠ‚ç‚¹
    
    Attributes:
        role_id: è§’è‰² ID
        depends_on: ä¾èµ–çš„è§’è‰² ID åˆ—è¡¨ï¼ˆç©ºè¡¨ç¤ºæ— ä¾èµ–ï¼Œå¯ç«‹å³æ‰§è¡Œï¼‰
    """
    role_id: str
    depends_on: list[str] = field(default_factory=list)

@dataclass
class ExecutionPlan:
    """
    DAG æ‰§è¡Œè®¡åˆ’
    
    Attributes:
        nodes: æ‰§è¡ŒèŠ‚ç‚¹åˆ—è¡¨
        reason: LLM ç»™å‡ºçš„è§„åˆ’ç†ç”±
    """
    nodes: list[ExecutionNode] = field(default_factory=list)
    reason: str = ""
    
    def get_ready_nodes(self, completed: set[str]) -> list[ExecutionNode]:
        """è·å–å½“å‰å¯æ‰§è¡Œçš„èŠ‚ç‚¹ï¼ˆä¾èµ–éƒ½å·²å®Œæˆï¼‰"""
        ready = []
        for node in self.nodes:
            if node.role_id in completed:
                continue
            if all(dep in completed for dep in node.depends_on):
                ready.append(node)
        return ready

class IntentRecognizer:
    """æ„å›¾è¯†åˆ«å™¨ - ç”Ÿæˆ DAG æ‰§è¡Œè®¡åˆ’"""
    
    # LLM è§„åˆ’æç¤ºè¯ï¼ˆæ ¸å¿ƒï¼‰
    SYSTEM_PROMPT = """ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½ä»»åŠ¡è§„åˆ’å™¨ï¼Œè´Ÿè´£åˆ†æç”¨æˆ·çš„è´­æˆ¿å’¨è¯¢é—®é¢˜ï¼Œ
å†³å®šéœ€è¦å“ªäº›ä¸“å®¶è§’è‰²æ¥å›ç­”ï¼Œä»¥åŠå®ƒä»¬ä¹‹é—´çš„æ‰§è¡Œä¾èµ–å…³ç³»ã€‚

## å¯ç”¨è§’è‰²
1. financial_advisorï¼ˆè´¢åŠ¡é¡¾é—®ï¼‰- è´·æ¬¾è®¡ç®—ã€ç¨è´¹ä¼°ç®—ã€æˆæœ¬åˆ†æ
2. policy_expertï¼ˆæ”¿ç­–ä¸“å®¶ï¼‰- é™è´­é™è´·ã€å…¬ç§¯é‡‘æ”¿ç­–ã€è´­æˆ¿èµ„æ ¼
3. market_analystï¼ˆå¸‚åœºåˆ†æå¸ˆï¼‰- æˆ¿ä»·èµ°åŠ¿ã€åŒºåŸŸå¯¹æ¯”ã€æ—¶æœºåˆ¤æ–­
4. purchase_consultantï¼ˆè´­æˆ¿é¡¾é—®ï¼‰- ç»¼åˆå»ºè®®ã€æ•´åˆå¤šæ–¹ä¿¡æ¯

## ä¾èµ–å…³ç³»åˆ¤æ–­è§„åˆ™
1. æ— ä¾èµ–ï¼ˆå¯å¹¶è¡Œï¼‰ï¼šä¸¤ä¸ªè§’è‰²çš„åˆ†æç›¸äº’ç‹¬ç«‹
2. æœ‰ä¾èµ–ï¼ˆéœ€ä¸²è¡Œï¼‰ï¼šä¸€ä¸ªè§’è‰²éœ€è¦å¦ä¸€ä¸ªè§’è‰²çš„ç»“æœ
3. æ•´åˆåœºæ™¯ï¼špurchase_consultant åº”è¯¥ä¾èµ–æ‰€æœ‰å…¶ä»–å‚ä¸çš„ä¸“å®¶

## è¾“å‡ºæ ¼å¼
```json
{
  "nodes": [
    {"role_id": "è§’è‰²ID", "depends_on": ["ä¾èµ–çš„è§’è‰²ID"]}
  ],
  "reason": "ç®€è¦è¯´æ˜è§„åˆ’ç†ç”±"
}
```"""
    
    async def plan_execution(self, user_input: str) -> ExecutionPlan:
        """åˆ†æç”¨æˆ·è¾“å…¥ï¼Œç”Ÿæˆ DAG æ‰§è¡Œè®¡åˆ’"""
        response = await self.llm.chat([
            {"role": "system", "content": self.SYSTEM_PROMPT},
            {"role": "user", "content": f"ç”¨æˆ·é—®é¢˜ï¼š{user_input}"}
        ], temperature=0.1)
        
        # è§£æ JSON å“åº”ï¼ŒéªŒè¯ DAG æœ‰æ•ˆæ€§
        plan = self._parse_plan_response(response)
        
        # æ£€æµ‹å¾ªç¯ä¾èµ–
        if not self._validate_dag(plan.nodes):
            # æ¸…é™¤æ‰€æœ‰ä¾èµ–ï¼Œé™çº§ä¸ºå¹¶è¡Œæ‰§è¡Œ
            for node in plan.nodes:
                node.depends_on = []
        
        return plan
    
    def _validate_dag(self, nodes: list[ExecutionNode]) -> bool:
        """ä½¿ç”¨æ‹“æ‰‘æ’åºæ£€æµ‹å¾ªç¯ä¾èµ–"""
        # æ„å»ºå…¥åº¦è¡¨ï¼Œæ‰§è¡Œæ‹“æ‰‘æ’åº
        # å¦‚æœè®¿é—®èŠ‚ç‚¹æ•° < æ€»èŠ‚ç‚¹æ•°ï¼Œå­˜åœ¨å¾ªç¯
        ...
```


### 3.6 Agentå¼•æ“æ ¸å¿ƒï¼ˆDAG è°ƒåº¦ï¼‰

```python
# app/agent/engine.py
"""
Agent å¼•æ“æ ¸å¿ƒ - DAG è°ƒåº¦å®ç°

æ ¸å¿ƒæ”¹è¿›ï¼š
1. ä½¿ç”¨ DAG è°ƒåº¦æ›¿ä»£ç®€å•ä¸²è¡Œæ‰§è¡Œ
2. æ”¯æŒå¹¶è¡Œæ‰§è¡Œæ— ä¾èµ–çš„è§’è‰²
3. ä½¿ç”¨ asyncio.gather() å®ç°çœŸæ­£çš„å¹¶è¡Œ
"""
import asyncio
from dataclasses import dataclass
from typing import AsyncGenerator
from .intent import ExecutionPlan, ExecutionNode, get_role

@dataclass
class RoleResult:
    """è§’è‰²æ‰§è¡Œç»“æœ"""
    role_id: str
    role_name: str
    content: str
    success: bool = True

class AgentEngine:
    """ä¼ªå¤šAgentå¼•æ“ - DAG è°ƒåº¦ç‰ˆæœ¬"""
    
    async def process(self, user_input: str, session_id: str, mode: str = "standard"):
        """å¤„ç†ç”¨æˆ·è¾“å…¥ï¼Œæµå¼è¿”å›ç»“æœ"""
        
        # 1. æ„å›¾è¯†åˆ«ï¼Œç”Ÿæˆ DAG æ‰§è¡Œè®¡åˆ’
        plan = await self.intent_recognizer.plan_execution(user_input)
        
        # 2. DAG è°ƒåº¦æ‰§è¡Œ
        if mode == "discussion" and len(plan.nodes) > 1:
            async for event in self._process_discussion_mode(user_input, plan, context):
                yield event
        else:
            async for event in self._process_dag_mode(user_input, plan, context):
                yield event
        
        yield {"type": "done"}
    
    async def _process_dag_mode(
        self, user_input: str, plan: ExecutionPlan, context
    ) -> AsyncGenerator[dict, None]:
        """
        DAG è°ƒåº¦æ¨¡å¼ï¼šæ ¹æ®ä¾èµ–å…³ç³»å¹¶è¡Œ/ä¸²è¡Œæ‰§è¡Œè§’è‰²
        
        ç®—æ³•ï¼š
        1. è·å–å½“å‰å¯æ‰§è¡ŒèŠ‚ç‚¹ï¼ˆä¾èµ–éƒ½å·²å®Œæˆï¼‰
        2. å•èŠ‚ç‚¹ï¼šç›´æ¥æ‰§è¡Œ
        3. å¤šèŠ‚ç‚¹ï¼šasyncio.gather() å¹¶è¡Œæ‰§è¡Œ
        4. å¾ªç¯ç›´åˆ°æ‰€æœ‰èŠ‚ç‚¹å®Œæˆ
        """
        completed: set[str] = set()  # å·²å®Œæˆçš„è§’è‰² ID
        
        while True:
            # è·å–å½“å‰å¯æ‰§è¡Œçš„èŠ‚ç‚¹
            ready_nodes = plan.get_ready_nodes(completed)
            
            if not ready_nodes:
                break  # æ²¡æœ‰å¯æ‰§è¡Œçš„èŠ‚ç‚¹äº†
            
            if len(ready_nodes) == 1:
                # å•èŠ‚ç‚¹ï¼Œç›´æ¥æ‰§è¡Œ
                node = ready_nodes[0]
                async for event in self._execute_node(node, user_input, context):
                    yield event
                completed.add(node.role_id)
            else:
                # å¤šèŠ‚ç‚¹ï¼Œå¹¶è¡Œæ‰§è¡Œ
                # å…ˆå‘é€æ‰€æœ‰ role_start äº‹ä»¶
                for node in ready_nodes:
                    role = get_role(node.role_id)
                    yield {"type": "role_start", "role": role.id, "name": role.name, "icon": role.icon}
                
                # å¹¶è¡Œæ‰§è¡Œæ‰€æœ‰è§’è‰²
                tasks = [self._execute_role_async(node, user_input, context) for node in ready_nodes]
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # æŒ‰é¡ºåºå‘é€ç»“æœ
                for node, result in zip(ready_nodes, results):
                    if isinstance(result, Exception):
                        yield {"type": "role_result", "role": node.role_id, "content": f"æ‰§è¡Œå‡ºé”™: {result}"}
                    else:
                        context.role_results[node.role_id] = result.content
                        yield {"type": "role_result", "role": result.role_id, "content": result.content}
                    completed.add(node.role_id)
    
    async def _execute_role_async(self, node: ExecutionNode, user_input: str, context) -> RoleResult:
        """å¼‚æ­¥æ‰§è¡Œè§’è‰²ï¼ˆç”¨äºå¹¶è¡Œæ‰§è¡Œï¼‰"""
        role = get_role(node.role_id)
        content = await self._execute_role(role, user_input, context)
        return RoleResult(role_id=role.id, role_name=role.name, content=content)
```

### 3.7 é«˜çº§æ¨¡å¼ï¼ˆDiscussion Modeï¼‰

é«˜çº§æ¨¡å¼ä¿æŒåŸæœ‰çš„å¤šè§’è‰²å¯¹è¯åå•†é€»è¾‘ï¼š

```python
    async def _process_discussion_mode(
        self, 
        user_input: str, 
        context: dict
    ) -> AsyncGenerator[dict, None]:
        """é«˜çº§æ¨¡å¼ï¼šå¤šè§’è‰²å¯¹è¯åå•†"""
        
        # 1. æ„å›¾è¯†åˆ«ï¼Œç¡®å®šå‚ä¸è®¨è®ºçš„è§’è‰²
        execution_plan = await self.intent_recognizer.plan_execution(user_input)
        participating_roles = execution_plan.roles
        
        # 2. å¤šè½®å¯¹è¯åå•†
        discussion_history = []
        max_rounds = 5  # æœ€å¤§è®¨è®ºè½®æ•°
        
        for round_num in range(max_rounds):
            for role in participating_roles:
                # é€šçŸ¥å‰ç«¯å½“å‰å‘è¨€è§’è‰²
                yield {"type": "role_start", "role": role.id, "name": role.name, "icon": role.icon}
                
                # è§’è‰²å‘è¨€ï¼ˆåŸºäºè®¨è®ºå†å²ï¼‰
                response = await self._role_discuss(role, user_input, discussion_history)
                discussion_history.append({"role": role.name, "content": response})
                
                # æ¨é€è®¨è®ºå†…å®¹
                yield {
                    "type": "discussion", 
                    "from": role.id, 
                    "name": role.name,
                    "icon": role.icon,
                    "content": response,
                    "round": round_num + 1
                }
            
            # æ£€æŸ¥æ˜¯å¦è¾¾æˆå…±è¯†æˆ–ä¿¡æ¯å……è¶³
            if await self._check_consensus(discussion_history, user_input):
                break
        
        # 3. è´­æˆ¿é¡¾é—®æ€»ç»“è®¨è®ºç»“æœ
        yield {"type": "role_start", "role": "consultant", "name": "è´­æˆ¿é¡¾é—®", "icon": "âœ…"}
        summary = await self._summarize_discussion(discussion_history, user_input)
        yield {"type": "role_result", "role": "consultant", "content": summary}
        
        yield {"type": "done"}
    
    async def _execute_role(self, role: Role, user_input: str, context: dict) -> str:
        """æ‰§è¡Œå•ä¸ªè§’è‰²çš„åˆ†æ"""
        
        # æ„å»ºæ¶ˆæ¯
        messages = [
            {"role": "system", "content": role.system_prompt},
            {"role": "user", "content": user_input}
        ]
        
        # æ·»åŠ ä¸Šä¸‹æ–‡
        if context.get("history"):
            messages = [messages[0]] + context["history"] + [messages[-1]]
        
        # è·å–è§’è‰²å¯ç”¨çš„å·¥å…·
        available_tools = [
            self.tools[t].to_openai_schema() 
            for t in role.tools 
            if t in self.tools
        ]
        
        # è°ƒç”¨LLM
        response = await self.llm.chat(messages, tools=available_tools if available_tools else None)
        
        # å¤„ç†å·¥å…·è°ƒç”¨
        message = response["choices"][0]["message"]
        if message.get("tool_calls"):
            # æ‰§è¡Œå·¥å…·
            tool_results = await self._execute_tools(message["tool_calls"])
            
            # å°†å·¥å…·ç»“æœåŠ å…¥å¯¹è¯ï¼Œå†æ¬¡è°ƒç”¨LLMç”Ÿæˆæœ€ç»ˆå›ç­”
            messages.append(message)
            for tool_call, result in tool_results:
                messages.append({
                    "role": "tool",
                    "tool_call_id": tool_call["id"],
                    "content": str(result)
                })
            
            final_response = await self.llm.chat(messages)
            return final_response["choices"][0]["message"]["content"]
        
        return message["content"]
    
    async def _execute_tools(self, tool_calls: list) -> list:
        """æ‰§è¡Œå·¥å…·è°ƒç”¨"""
        results = []
        for tool_call in tool_calls:
            func_name = tool_call["function"]["name"]
            func_args = json.loads(tool_call["function"]["arguments"])
            
            if func_name in self.tools:
                result = await self.tools[func_name].execute(**func_args)
                results.append((tool_call, result))
        
        return results
    
    async def _synthesize(self, role_results: dict, user_input: str) -> str:
        """æ•´åˆå¤šè§’è‰²ç»“æœ"""
        synthesis_prompt = f"""åŸºäºä»¥ä¸‹å„ä¸“å®¶çš„åˆ†æï¼Œç»™å‡ºç»¼åˆè´­æˆ¿å»ºè®®ï¼š

ç”¨æˆ·é—®é¢˜ï¼š{user_input}

å„ä¸“å®¶åˆ†æï¼š
{chr(10).join([f"ã€{ROLES[r].name}ã€‘{c}" for r, c in role_results.items()])}

è¯·ç»¼åˆä»¥ä¸Šä¿¡æ¯ï¼Œç»™å‡ºï¼š
1. æ ¸å¿ƒç»“è®º
2. ç»¼åˆå»ºè®®
3. é£é™©æç¤º
4. ä¸‹ä¸€æ­¥è¡ŒåŠ¨"""
        
        response = await self.llm.chat([
            {"role": "system", "content": ROLES["purchase_consultant"].system_prompt},
            {"role": "user", "content": synthesis_prompt}
        ])
        
        return response["choices"][0]["message"]["content"]
```

### 3.7 RAGæ£€ç´¢å®ç°

å®é™…å®ç°é‡‡ç”¨ Chroma HTTP å®¢æˆ·ç«¯è¿æ¥è¿œç¨‹æœåŠ¡ï¼Œä½¿ç”¨æœ¬åœ° BGE ä¸­æ–‡æ¨¡å‹ç”Ÿæˆå‘é‡ã€‚

**æ¶æ„ç‰¹ç‚¹**ï¼š
- ä½¿ç”¨ `HttpClient` è¿æ¥ Docker ä¸­çš„ Chroma æœåŠ¡ï¼ˆç«¯å£ 8001ï¼‰
- ä½¿ç”¨æœ¬åœ° BGE æ¨¡å‹ï¼ˆ`bge-base-zh-v1.5`ï¼‰ç”Ÿæˆä¸­æ–‡å‘é‡ï¼Œæ•ˆæœæ›´å¥½
- æ”¯æŒé™çº§ï¼šChroma è¿æ¥å¤±è´¥æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å…³é”®è¯åŒ¹é…

```python
# app/db/chroma.py
import chromadb
from chromadb.config import Settings as ChromaSettings
from chromadb.utils import embedding_functions
from pathlib import Path

class ChromaClient:
    """Chroma å‘é‡æ•°æ®åº“å®¢æˆ·ç«¯"""
    
    # Collection åç§°å¸¸é‡
    COLLECTION_POLICIES = "policies"  # é™è´­é™è´·æ”¿ç­–
    COLLECTION_FAQ = "faq"            # å¸¸è§é—®é¢˜
    COLLECTION_GUIDES = "guides"      # è´­æˆ¿æŒ‡å—
    
    def __init__(
        self, 
        host: str = "localhost", 
        port: int = 8001,
        embedding_model_path: str = None  # å¦‚ ~/models/bge-base-zh-v1.5
    ):
        self._host = host
        self._port = port
        self._client = None
        self._embedding_fn = None
        
        # è®¾ç½®æœ¬åœ° BGE embedding æ¨¡å‹
        if embedding_model_path:
            model_path = Path(embedding_model_path).expanduser()
            if model_path.exists():
                self._embedding_fn = embedding_functions.SentenceTransformerEmbeddingFunction(
                    model_name=str(model_path)
                )
        
        # é™çº§åˆ°é»˜è®¤æ¨¡å‹
        if self._embedding_fn is None:
            self._embedding_fn = embedding_functions.DefaultEmbeddingFunction()
    
    async def connect(self) -> None:
        """è¿æ¥ Chroma æœåŠ¡"""
        self._client = chromadb.HttpClient(
            host=self._host,
            port=self._port,
            settings=ChromaSettings(anonymized_telemetry=False)
        )
        self._client.heartbeat()  # æµ‹è¯•è¿æ¥
    
    async def disconnect(self) -> None:
        """æ–­å¼€è¿æ¥"""
        self._client = None
    
    def query(
        self,
        collection_name: str,
        query_text: str,
        n_results: int = 5,
        where: dict = None
    ) -> dict:
        """æŸ¥è¯¢ç›¸ä¼¼æ–‡æ¡£"""
        collection = self._client.get_or_create_collection(
            name=collection_name,
            embedding_function=self._embedding_fn
        )
        
        query_params = {
            "query_texts": [query_text],
            "n_results": n_results
        }
        if where:
            query_params["where"] = where
        
        return collection.query(**query_params)
```

**åº”ç”¨å¯åŠ¨æ—¶åˆå§‹åŒ–**ï¼ˆ`app/main.py`ï¼‰ï¼š

```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    # åˆå§‹åŒ– Chroma å‘é‡æ•°æ®åº“
    from app.db import chroma
    try:
        chroma.chroma_client = chroma.ChromaClient(
            host="localhost",
            port=8001,
            embedding_model_path=settings.EMBEDDING_MODEL_PATH
        )
        await chroma.chroma_client.connect()
        logger.info("Chroma å‘é‡æ•°æ®åº“è¿æ¥æˆåŠŸ")
    except Exception as e:
        logger.warning(f"Chroma è¿æ¥å¤±è´¥ï¼Œå°†ä½¿ç”¨å…³é”®è¯åŒ¹é…: {e}")
        chroma.chroma_client = None
    
    yield
    
    # å…³é—­æ—¶æ–­å¼€è¿æ¥
    if chroma.chroma_client:
        await chroma.chroma_client.disconnect()
```

**é™çº§ç­–ç•¥**ï¼šæ”¿ç­–æ£€ç´¢å·¥å…·ï¼ˆ`app/agent/tools/policy.py`ï¼‰åœ¨ Chroma ä¸å¯ç”¨æ—¶è‡ªåŠ¨ä½¿ç”¨å…³é”®è¯åŒ¹é…ã€‚


---

## å››ã€APIæ¥å£è®¾è®¡

### 4.1 å¯¹è¯æ¥å£

```python
# app/api/chat.py
from fastapi import APIRouter, HTTPException, Depends
from fastapi.responses import StreamingResponse
from pydantic import BaseModel, Field
from typing import Optional

router = APIRouter()

class ChatRequest(BaseModel):
    session_id: str = Field(..., description="ä¼šè¯ ID")
    message: str = Field(..., description="ç”¨æˆ·æ¶ˆæ¯")
    mode: str = Field(default="standard", description="æ‰§è¡Œæ¨¡å¼: standard æˆ– discussion")
    conversation_id: Optional[str] = Field(default=None, description="å¯¹è¯IDï¼ˆç”¨äºæŒä¹…åŒ–ï¼‰")
    user_id: Optional[str] = Field(default=None, description="ç”¨æˆ·IDï¼ˆå¯é€‰ï¼‰")

@router.post("/chat")
async def chat(request: ChatRequest):
    """
    å¯¹è¯æ¥å£ï¼ˆæµå¼å“åº”ï¼‰
    
    è¿”å› SSE äº‹ä»¶ç±»å‹ï¼š
    - conversation_created: æ–°å¯¹è¯åˆ›å»ºï¼ŒåŒ…å« conversation_id
    - thinking_start: æ€è€ƒå¼€å§‹ï¼ˆAI å¼€å§‹åˆ†æé—®é¢˜ï¼‰
    - thinking_step: æ€è€ƒæ­¥éª¤ï¼ŒåŒ…å« step_type å’Œ content
      - step_type: "planning" - æ„å›¾è¯†åˆ«å’Œè§„åˆ’é˜¶æ®µ
      - step_type: "role_dispatch" - è§’è‰²è°ƒåº¦é˜¶æ®µï¼Œå±•ç¤ºå“ªä¸ªè§’è‰²æ­£åœ¨åˆ†æ
    - role_start: è§’è‰²å¼€å§‹å¤„ç†
    - tool_call: å·¥å…·è°ƒç”¨äº‹ä»¶ï¼ŒåŒ…å« tool_nameã€tool_argsã€role
    - tool_result: å·¥å…·æ‰§è¡Œç»“æœï¼ŒåŒ…å« tool_nameã€contentã€role
    - role_result: è§’è‰²å¤„ç†ç»“æœ
    - discussion: è®¨è®ºäº‹ä»¶ï¼ˆé«˜çº§æ¨¡å¼ï¼‰
    - error: é”™è¯¯äº‹ä»¶
    - done: å¤„ç†å®Œæˆ
    """
    
    async def generate():
        async for chunk in agent_engine.process(
            user_input=request.message,
            context=get_session_context(request.session_id),
            mode=request.mode
        ):
            yield f"data: {json.dumps(chunk, ensure_ascii=False)}\n\n"
    
    return StreamingResponse(
        generate(),
        media_type="text/event-stream"
    )

@router.post("/chat/sync")
async def chat_sync(request: ChatRequest):
    """å¯¹è¯æ¥å£ï¼ˆåŒæ­¥å“åº”ï¼Œç”¨äºæµ‹è¯•ï¼‰"""
    results = []
    async for chunk in agent_engine.process(
        user_input=request.message,
        context=get_session_context(request.session_id)
    ):
        results.append(chunk)
    return {"results": results}
```

### 4.2 è®¡ç®—å™¨æ¥å£

```python
# app/api/calculator.py
from fastapi import APIRouter
from pydantic import BaseModel

router = APIRouter()

class LoanCalcRequest(BaseModel):
    price: float           # æˆ¿ä»·
    down_payment_ratio: float  # é¦–ä»˜æ¯”ä¾‹
    years: int             # è´·æ¬¾å¹´é™
    rate: float            # åˆ©ç‡
    method: str = "equal_payment"  # è¿˜æ¬¾æ–¹å¼

class TaxCalcRequest(BaseModel):
    price: float           # æˆ¿ä»·
    area: float            # é¢ç§¯
    is_first_home: bool    # æ˜¯å¦é¦–å¥—
    house_age_years: int   # æˆ¿é¾„

@router.post("/calc/loan")
async def calc_loan(request: LoanCalcRequest):
    """è´·æ¬¾è®¡ç®—"""
    tool = TOOL_REGISTRY["calc_loan"]
    result = await tool.execute(**request.dict())
    return result

@router.post("/calc/tax")
async def calc_tax(request: TaxCalcRequest):
    """ç¨è´¹è®¡ç®—"""
    tool = TOOL_REGISTRY["calc_tax"]
    result = await tool.execute(**request.dict())
    return result

@router.post("/calc/total_cost")
async def calc_total_cost(request: dict):
    """æ€»æˆæœ¬è®¡ç®—"""
    tool = TOOL_REGISTRY["calc_total_cost"]
    result = await tool.execute(**request)
    return result
```

### 4.3 å¸‚åœºæ•°æ®æ¥å£

```python
# app/api/market.py
from fastapi import APIRouter

router = APIRouter()

@router.get("/market/{city}")
async def get_market_data(city: str):
    """è·å–åŸå¸‚å¸‚åœºæ•°æ®"""
    data = load_market_data(city)
    return data

@router.get("/market/{city}/districts")
async def get_district_data(city: str):
    """è·å–å„åŒºæ•°æ®"""
    data = load_district_data(city)
    return data

@router.get("/market/{city}/trend")
async def get_price_trend(city: str, district: str = None):
    """è·å–æˆ¿ä»·èµ°åŠ¿"""
    data = load_price_trend(city, district)
    return data
```

### 4.4 å¯¹è¯å†å²æ¥å£

```python
# app/api/conversation.py
from fastapi import APIRouter

router = APIRouter(prefix="/conversations")

@router.get("")
async def list_conversations(user_id: str = None, limit: int = 20, offset: int = 0):
    """è·å–å¯¹è¯åˆ—è¡¨"""
    pass

@router.post("")
async def create_conversation(user_id: str = None, title: str = None):
    """åˆ›å»ºæ–°å¯¹è¯"""
    pass

@router.get("/{conversation_id}")
async def get_conversation(conversation_id: str, include_messages: bool = True):
    """è·å–å¯¹è¯è¯¦æƒ…ï¼ˆå«æ¶ˆæ¯åˆ—è¡¨ï¼‰"""
    pass

@router.put("/{conversation_id}")
async def update_conversation(conversation_id: str, title: str):
    """æ›´æ–°å¯¹è¯æ ‡é¢˜"""
    pass

@router.delete("/{conversation_id}")
async def delete_conversation(conversation_id: str):
    """åˆ é™¤å¯¹è¯ï¼ˆçº§è”åˆ é™¤æ¶ˆæ¯ï¼‰"""
    pass

@router.get("/{conversation_id}/messages")
async def get_messages(conversation_id: str, limit: int = 50, offset: int = 0):
    """è·å–å¯¹è¯çš„æ¶ˆæ¯åˆ—è¡¨"""
    pass
```

---

## äº”ã€å‰ç«¯å®ç°è¦ç‚¹

### 5.1 å¯¹è¯é¡µé¢

```vue
<!-- src/views/Chat.vue -->
<template>
  <div class="chat-container">
    <div class="message-list" ref="messageList">
      <ChatMessage 
        v-for="msg in messages" 
        :key="msg.id"
        :message="msg"
      />
    </div>
    
    <div class="input-area">
      <el-input
        v-model="inputText"
        placeholder="è¯·è¾“å…¥æ‚¨çš„é—®é¢˜..."
        @keyup.enter="sendMessage"
      />
      <el-button type="primary" @click="sendMessage">å‘é€</el-button>
    </div>
  </div>
</template>

<script setup>
import { ref } from 'vue'
import { chatStream } from '@/api'

const messages = ref([])
const inputText = ref('')

async function sendMessage() {
  if (!inputText.value.trim()) return
  
  // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯
  messages.value.push({
    id: Date.now(),
    role: 'user',
    content: inputText.value
  })
  
  const userInput = inputText.value
  inputText.value = ''
  
  // æµå¼æ¥æ”¶å›å¤
  const eventSource = chatStream(userInput)
  
  let currentRole = null
  let currentContent = ''
  
  eventSource.onmessage = (event) => {
    const data = JSON.parse(event.data)
    
    if (data.type === 'role_start') {
      // æ–°è§’è‰²å¼€å§‹
      currentRole = data
      messages.value.push({
        id: Date.now(),
        role: 'assistant',
        agentRole: data,
        content: ''
      })
    } else if (data.type === 'role_result') {
      // æ›´æ–°è§’è‰²å†…å®¹
      const lastMsg = messages.value[messages.value.length - 1]
      lastMsg.content = data.content
    } else if (data.type === 'done') {
      eventSource.close()
    }
  }
}
</script>
```

### 5.2 æ¶ˆæ¯ç»„ä»¶

```vue
<!-- src/components/ChatMessage.vue -->
<template>
  <div :class="['message', message.role]">
    <div v-if="message.agentRole" class="role-tag">
      <span class="icon">{{ message.agentRole.icon }}</span>
      <span class="name">{{ message.agentRole.name }}</span>
    </div>
    <div class="content" v-html="renderMarkdown(message.content)"></div>
  </div>
</template>
```

---

## å…­ã€éƒ¨ç½²æ–¹æ¡ˆ

### 6.1 Docker Compose

```yaml
# docker-compose.yml
version: '3.8'

services:
  backend:
    build: ./backend
    ports:
      - "8000:8000"
    environment:
      - DEEPSEEK_API_KEY=${DEEPSEEK_API_KEY}
      - DATABASE_URL=postgresql://admin:password@postgres:5432/house_assistant
      - REDIS_URL=redis://redis:6379/0
    volumes:
      - ./data:/app/data
      - ./chroma_db:/app/chroma_db
    depends_on:
      - postgres
      - redis
  
  frontend:
    build: ./frontend
    ports:
      - "3000:80"
    depends_on:
      - backend

  postgres:
    image: postgres:15
    environment:
      POSTGRES_DB: house_assistant
      POSTGRES_USER: admin
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  postgres_data:
  redis_data:
```

### 6.2 ç¯å¢ƒå˜é‡

```bash
# .env
DEEPSEEK_API_KEY=your_api_key_here
DEEPSEEK_BASE_URL=https://api.deepseek.com
DATABASE_URL=postgresql://admin:password@localhost:5432/house_assistant
REDIS_URL=redis://localhost:6379/0
```

---

## ä¸ƒã€å¼€å‘è®¡åˆ’

| é˜¶æ®µ | ä»»åŠ¡ | é¢„è®¡æ—¶é—´ |
|------|------|---------|
| **Phase 1** | æ•°æ®å‡†å¤‡ | 2-3å¤© |
| | - ç”Ÿæˆå¸‚åœºæ¨¡æ‹Ÿæ•°æ® | |
| | - ç¼–å†™çŸ¥è¯†åº“æ–‡æ¡£ | |
| | - åˆå§‹åŒ–å‘é‡åº“ | |
| **Phase 2** | åç«¯æ ¸å¿ƒ | 5-7å¤© |
| | - LLMå®¢æˆ·ç«¯å°è£… | |
| | - å·¥å…·å®ç°ï¼ˆè´¢åŠ¡ã€å¸‚åœºã€æ”¿ç­–ï¼‰ | |
| | - Agentå¼•æ“ | |
| | - RAGæ£€ç´¢ | |
| | - APIæ¥å£ | |
| **Phase 3** | å‰ç«¯å¼€å‘ | 4-5å¤© |
| | - å¯¹è¯é¡µé¢ | |
| | - è®¡ç®—å™¨é¡µé¢ | |
| | - å¸‚åœºåˆ†æé¡µé¢ | |
| **Phase 4** | é›†æˆæµ‹è¯• | 2-3å¤© |
| | - ç«¯åˆ°ç«¯æµ‹è¯• | |
| | - æ€§èƒ½ä¼˜åŒ– | |
| | - Bugä¿®å¤ | |

**æ€»è®¡**: çº¦2-3å‘¨

---

## å…«ã€ä¾èµ–æ¸…å•

### åç«¯ requirements.txt

```txt
fastapi==0.109.0
uvicorn==0.27.0
httpx==0.26.0
pydantic==2.5.3
python-dotenv==1.0.0
chromadb==0.4.22
sentence-transformers==2.2.2
sqlalchemy==2.0.25
asyncpg==0.29.0
redis==5.0.1
```

### å‰ç«¯ package.json

```json
{
  "dependencies": {
    "vue": "^3.4.0",
    "vue-router": "^4.2.0",
    "axios": "^1.6.0",
    "element-plus": "^2.5.0",
    "echarts": "^5.4.0",
    "marked": "^11.0.0"
  },
  "devDependencies": {
    "vite": "^5.0.0",
    "@vitejs/plugin-vue": "^5.0.0"
  }
}
```
